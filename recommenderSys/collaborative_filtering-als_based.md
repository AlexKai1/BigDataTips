#Collaborative Filtering-Als Based

## 1.算法详解

对于一个users-items-rating的评分数据集，ALS会建立一个user * product的m* n的矩阵。  
其中，m为users的数量，n为products的数量,但是在这个数据集中，并不是每个用户都对每个产品进行过评分，所以这个矩阵往往是稀疏的，用户i对产品j的评分往往是空的.ALS所做的事情就是将这个稀疏矩阵通过一定的规律填满，这样就可以从矩阵中得到任意一个user对任意一个product的评分，ALS填充的评分项也称为用户i对产品j的预测得分。  
所以说，ALS算法的核心就是通过什么样子的规律来填满（预测）这个稀疏矩阵。  

它是这么做的：假设m* n的评分矩阵R，可以被近似分解成U* (V)T   
U为m * d的用户特征向量,  
矩阵V为n* d的产品特征向量矩阵（(V)T代表V的转置）  
d为user/product的特征值的数量 

关于d这个值的理解，大概可以是这样的对于每个产品，可以从d个角度(特征)进行评价，以电影为例，可以从主演，导演，特效，剧情4个角度来评价一部电影，那么d就等于4可以认为，每部电影在这4个角度上都有一个固定的基准评分值.  
例如《末日崩塌》这部电影是一个产品，它的特征向量是由d个特征值组成的d=4，有4个特征值，分别是主演，导演，特效，剧情每个特征值的基准评分值分别为（满分为1.0）：  
主演：0.9（大光头还是那么霸气）导演：0.7特效：0.8剧情：0.6  
矩阵V由n个product * d个特征值组成.  
 
电影的综合评分=(u 1* v1+u2 * v2+u3 * v3+u4 * v4)    

其中u1-4为用户A的特征值，v1-4为之前所说的电影的特征值.  
对于之前ALS算法的这个假设m * n的评分矩阵R，可以被近似分解成U * (V)T就是成立的，某个用户对某个产品的评分可以通过矩阵U某行和矩阵V（转置）的某列相乘得到。  
那么现在的问题是，如何确定用户和产品的特征值？  

##2.实现  
用户和产品的特征值,我们现在都没有。而协同过滤算法就是为了解决这个问题的。  

大体逻辑： 
1.先随机估算出用户特征向量  
2.利用估算出来的 用户特征向量和用户看过的电影的评分数据，估算出产品的特征向量  
3.利用估算出来的产品特征向量，反向估算出用户特征向量  
4.重复步骤 2 ，直到用户参数 和产品特征向量收敛到一个合适的值.  

这个方法，就是ALS算法,交替的最小二乘法.

协同过滤的一个重要的效应是，当用户对某个电影进行评分时，会帮助算法学习电影的特征，这有利于系统向所有用户推荐合适的电影，同时也让算法更好地学习到用户的偏好。 

那如何将估算的行为呢？这个实际上是个线性回归问题，即我们利用用户对现有电影的所有的评分学习出其特征值。根据线性回归算法的成本公式，我们的目标是求解线性回归算法的成本函数的最小值时的值。假设 m^{(j)} 是用户 j 评价过的电影的总数。n 为电影的特征数，r(i,j) = 1 表示用户 j 对电影 i 进行过了评价，y^{(i,j)} 就是它的分数。r(i,j) = 0 表示用户还没观看过这个电影。theta表示用户的特征向量，x表示电影的特征向量。

用户J的学习成本：  

![特征数目](http://upload-images.jianshu.io/upload_images/184896-bdb081e0e853a8dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

求下面这个成本函数的最小值，就得到了用户 j 的特征值：  
![最小值](http://upload-images.jianshu.io/upload_images/184896-91b84698a9e89719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

计算电影 i 的特征向量:
![电影最小值](http://upload-images.jianshu.io/upload_images/184896-6ee340b1f8b9e18f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

实际上，轮流不停的计算上面两者的效率是比较低的，我们可以把两者合起来，一起计算。  
总成本函数为:  
![总成本函数](http://upload-images.jianshu.io/upload_images/184896-7b88adcbc370eb36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这样我们可以更新协同过滤算法的实现步骤：  

* 用较小的随机数来初始化 $x^{(1)}, x^{(2)}m, ... ,x^{(n_m)}, \theta^{(1)}, \theta^{(2)}, ... , \theta^{(n_u)}$。为什么要用较小的随机数来初始化，而不全用零呢？这是因为我们需要让这些变量具有不同的初始值，以便不会让两个变量变成同一个特征。
* 最小化成本函数 $J(x^{(1)}, x^{(2)}m, ... ,x^{(n_m)}, \theta^{(1)}, \theta^{(2)}, ... , \theta^{(n_u)})$ ，可以使用梯度下降或其他的优化过的高级算法。其参数迭代公式为
![参数迭代公式](http://upload-images.jianshu.io/upload_images/184896-2c440a8438ed8631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 学习出参数后，针对一个用户 j 的参数为 \theta^{(j)}，针对这个用户没有看过的电影，学习到的特征为 x^{(i)}，那么可以预测到这个用户对这个电影的评分将是 (\theta^{(j)})^T x^{(i)}。


## 参考
知乎ALS <https://www.zhihu.com/question/31509438/answer/52268608>

计算公式 <http://www.jianshu.com/p/9b06ef8c79fa>